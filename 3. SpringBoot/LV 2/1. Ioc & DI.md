---
tags:
  - fragment
  - spring
text: "[[Spring]]"
---
# IoC & DI
## IoC
제어의 역전
Inversion of Control
[[0. 오브젝트와 의존관계#제어의 역전|IoC]]
##### 간단한 예시
기존에 자바에서 객체를 생성할 떄는 객체가 필요한 곳에서 직접 생성했다.
~~~java
public static void main(String[] args) {  
    Dog dog = new Dog()
}
~~~
이런식으로 말이다.

제어의 역전은 다른객체를 직접 생성하거나 제어하는 것이 아니라
**외부에서 관리하는 객체를 가져와 사용**하는 것을 말한다.

개발자가 객체의 생명주기 및 의존성 관리를 하던 것을 스프링이 대신 처리

즉, 어딘가에서 받아온 객체를 할당한다.

~~~java
public static void main(String[] args) {  
	  private Dog dog;
}
~~~

#### '의존'의 의미
 A가 B에 의존한다 = B가 변하면 A에 영향을 미친다.
~~~java
Class B{
	public void go(){
		System.out.println("출력");
	}
}
Class A{
	public void go(){
		new B().go();
	}
}
~~~
B가 수정이 되면 A도 같이 수정해 줘야 한다. (의존)

#### IoC 컨테이너
스프링에서는 오브젝트의 생성, 관계설정, 사용, 제거 등의 작업을 코드대신 독립된 컨테이너가 담당한다.
이러한 IoC를 담당하는 컨테이너를 `IoC컨테이너` 라고 한다.

##### IoC 컨테이너의 종류
- BeanFactory 
	- 단순히 컨테이너에서 객체를 생성하고 DI를 처리하는 기능만 제공
- ApplicationContext
	- BeanFactory + 스프링 각종 부가기능 추가로 제공
	- 추가 기능이 더 있다는 것은 BeanFactory를 상속받았다는 뜻이다.
일반적으로 ApplicationContext를 보편적으로 사용함 (기능이 많으니까)

~~~java
public interface ApplicationContext extends ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver{ };
~~~


## DI
의존성 주입
Dependency Injection
[[0. 오브젝트와 의존관계#제어의 역전|DI]]
제어의 역전을 구현하기 위해 사용하는 방법
`{java}@Autowired` 어노테이션은 스프링 컨테이너에 있는 빈(Bean)이라는 것을 주입

~~~java
public class A{
	// A에서 B를 주입받음
	@Autowired 
	B b;
}
~~~
직접 객체를 생성하지 않고 객체를 주입받음

![[CleanShot 2024-08-05 at 14.52.11@2x.jpg|500]]
좀더 딥하게 다룰 시간이 있을 것이다.


# IoC 컨테이너 활용
## 예시 1
ApplicationContext
~~~java
interface ApplicationContext {
	Object getBean(String name);
}

// 빈(Bean)을 관리하는 간단한 IoC 컨테이너 구현
public class SimpleApplicationContext implements ApplicationContext {
		// bean을 저장하기 위해 HashMap사용
		private Map<String, Object> beans = new HashMap<>();
	
	// 빈을 등록하는 메서드
	// name : bean의 이름
	// bean : bean 객체 
	public void registerBean(String name, Object bean) {
			beans.put(name, bean);
	}

	// 등록된 빈을 가져오는 메서드
	// name : bean의 이름
	// return : 찾은 bean 객체, 없으면 null
	public Object getBean(String name) {
			return beans.get(name);
	}
}
~~~

Service
~~~java
// 서비스 인터페이스
interface Service{
		String getUserName();
}
// 사용자 서비스 구현 클래스
public class UserService implements Service {
		public String getUserName(){
			return "Alice";
		}
}
~~~

Main
~~~java
public class Main {
	public static void main(String[] args) {
		// IoC 컨테이너 생성
		SimpleApplicationContext context = new SimpleApplicationContext();
		// UserService 키 값을 "name" 이라는 이름으로 등록
		context.registerBean("name", new UserService());
		// "name" 으로 등록된 빈을 Service 타입으로 가져옴
		Service userService = (Service) context.getBean("name");
		// UserService의 getUserName 메서드를 호출하여 사용자 이름을 얻고 출력
		System.out.println(userService.getUserName());
	}
}
~~~

### 코드 분석
- 객체 생성과 의존성 관리를 직접하지 않고 `SimpleApplicationContext`에게 위임
  `SimpleApplicationContext` 가 IoC 컨테이너 역할을 한다
- Bean : IoC 컨테이너에 등록되는 객체. 여기서는 `UserService`가 Bean에 해당한다.
- 의존성 주입 : `UserService` 객체를 직접 생성하는 대신, IoC컨테이너에서 가져와서 사용
  이를 통해 코드의 결합도를 낮추고 유지보수성을 높일 수 있다.

## 예시 2
더 쉬운 예제
~~~java
@Service  // bean 으로 등록될 것을 의미 (@Component)
public class GreetingService {
    public String getGreeting() {
        return "Hello, Spring Boot!";
    }
}
~~~

~~~java
@RestController
public class GreetingController {
	
    private final GreetingService greetingService;

    // 생성자를 통해 의존성 주입
    public GreetingController(GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    @GetMapping("/greeting")
    public String greeting() {
        return greetingService.getGreeting();
    }
}
~~~



`ApplicationContext` 인터페이스를 구현한 클래스 `SimpleApplicationContext`
IoC 컨테이너가 제대로 동작하려면 2가지가 필요하다
- POJO 클래스
- 메타 정보

## POJO 
Java로 생성하는 순수한 객체
- Java스펙 외에 다른 기술이나 규약에 얽매이지 않아야 한다.
- 특정환경에 종속적이지 않아야 한다. (프레임워크로부터 독립적)


## 메타 정보
==빈을 어떻게 만들고 어떻게 동작하게 할 것인가에 관한 정보==
- 빈 아이디, 이름, 별칭 : 빈 오브젝트를 구분할 수 있는 식별자
- 클래스 또는 클래스 이름: 빈으로 만들 POJO 클래스 또는 서비스 클래스 정보
- 스코프: 싱글톤, 프로토타입과 같은 빈의 생성 방식과 존재 범위
- 프로퍼티 값 또는 참조: DI에 사용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름
- 생성자 파라미터 값 또는 참조 : DI에 사용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름
- 지연 로딩 여부, 우선 빈 여부, 자동와이어링 여부, 부모 빈 정보, 빈팩토리 이름 등

