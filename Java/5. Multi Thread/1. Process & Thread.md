---
tags:
  - java
  - fragment
---

# 멀티태스킹 (Multi-Tasking)
하나의 컴퓨터 시스템이 동시에 여러 작업을 수행하는 능력.
CPU는 초당 수십억 번 이상의 연산을 수행할 수 있다.
CPU가 매우 빠르게 여러 프로그램의 코드를 번갈아 실행하여 작업이 동시에 실행되는 것처럼 보이게 한다.
이를 **시분할(Time Sharing)** 기법이라 하며, 단일 CPU에서도 멀티태스킹을 구현할 수 있다.
![[!Resources/Excalidraw/MultiThread.md#^group=5_rHpE5SeiEC7CSKg-GE9|900]]
# 멀티프로세싱 (Multi-Processing)
여러 CPU 코어를 활용하여 동시에 작업을 처리하는 기술. (병렬 처리)
각 작업은 독립적인 **프로세스(Process)** 로 실행되며, **독립된** 메모리 공간을 사용.
![[!Resources/Excalidraw/MultiThread.md#^group=oJZ15ICVvMzBCVvfptIq5|900]]

##### 멀티태스킹 vs 멀티프로세싱
###### 멀티태스킹
소프트웨어 기반으로 CPU시간을 분할하여 각 작업에 할당
- 실행 단위 : 스레드
- 병렬성 : 동시성 (단일 CPU 에서도 가능)
- 동일 프로세스 내에서 자원 공유
###### 멀티프로세싱
하드웨어 기반으로 여러 CPU를 사용하여 동시에 여러 작업을 수행
- 실행 단위 : 프로세스
- 병렬성 : 실제 병렬 처리 (멀티코어 활용)
- 독립적인 메모리 공간 사용

> [!note] 동시성 vs 병렬성
> - 동시성: 여러 작업이 교대로 실행되며, 작업이 동시에 진행되는 것처럼 보임.
> - 병렬성: 물리적으로 여러 CPU 코어에서 작업이 실제로 동시에 실행됨.

| 구분     | 멀티태스킹             | 멀티프로세싱           |
| ------ | ----------------- | ---------------- |
| 기반 기술  | 소프트웨어 (CPU 시간 분할) | 하드웨어 (여러 CPU 사용) |
| 실행 단위  | 스레드(Thread)       | 프로세스(Process)    |
| 병렬성    | 동시성 (단일 CPU 가능)   | 실제 병렬 처리         |
| 메모리 사용 | 동일 프로세스 내 자원 공유   | 독립적인 메모리 공간 사용   |
|        |                   |                  |
# 프로세스 (Process)
![[!Resources/Excalidraw/MultiThread.md#^group=JU1bdqdVxNDYAbRgQESeW|900]]
프로그램은 실행되기 전까지는 단순한 파일일 뿐이다.  
프로그램을 실행하면 **운영체제 안에서 실행 중인 프로그램**인 프로세스가 만들어지고, 독립적인 메모리 공간을 사용한다.
프로세스는 서로 간섭하거나 접근할 수 없으며, 충돌해도 다른 프로세스에 영향을 미치지 않는다.

> [!note]
> 자바 언어로 비유하자면 "프로그램 = 클래스", "프로세스 = 인스턴스"로 비유할 수 있겠다.
###### 프로세스의 [[6. Static#메모리 구조|메모리 구성]]
- 코드 섹션 : 실행할 프로그램의 코드
- 데이터 섹션 : 전역변수 및 정적변수
- 힙 (Heap) : 동적으로 할당되는 메모리
- 스택 (Stack) : 메서드 호출 시 생성되는 지역 변수와 반환 주소
# 스레드
스레드는 **프로세스 내에서 실행되는 작업의 단위**이다.  
한 프로세스에 여러 스레드가 존재할 수 있으며, 같은 메모리 공간을 공유한다.  
스레드는 가벼워 생성 및 관리가 단순하다.
###### 스레드의 메모리 구성
- 공유 메모리 : 프로세스의 코드 섹션, 데이터 섹션, 힙(메모리)
- 개별 스택 :  각 스레드가 고유하게 가짐
# 프로그램 실행 과정
프로그램이 실행되면 운영체제는 디스크의 프로그램을 메모리로 로드하여 프로세스를 생성한다.  
프로세스의 코드는 **스레드**라는 **흐름**에 따라 실행된다.

단일 스레드 프로그램은 한 번에 하나의 작업만 수행한다.  
**멀티스레드**는 코드를 실행하는 흐름이 여러 개로 나뉘어 동시에 작업을 처리할 수 있다.

> [!note] 보다 구체적인 프로그램 실행 과정
> - 운영체제가 디스크에서 프로그램 바이너리를 읽음.
> - 메모리 공간에 할당하고 프로세스 생성.
> - 메모리 구조(코드, 데이터, 힙, 스택)를 초기화.
> - 첫 번째 스레드 실행 시작.


# 스케줄링 (Scheduling)
- CPU가 어떤 작업을 언제, 얼마나 실행할지는 운영체제가 결정
- 운영체제는 작업 우선순위와 최적화를 통해 CPU 활용도를 극대화.
- 예를 들어, 운영체제는 사용자 입력(고 우선순위)과 백그라운드 업데이트(저 우선순위) 작업 간의 균형을 조정
### 단일 코어 스케줄링
운영체제는 내부에 스케줄링 큐를 가지고 있고, 각각의 스레드는 스케줄링 큐에서 대기한다.
하나의 CPU 코어가 여러 스레드를 교대로 실행하며, 각 스레드는 시간 단위(Time Slice)로 번갈아 CPU를 점유
![[!Resources/Excalidraw/MultiThread.md#^group=u3-iho91-IH4-6YzLZOme|900]]
스레드 A-1을 CPU로 연산 수행 -> 잠시 멈추고 다시 스케줄링 큐에 넣는다.
-> 스레드 B-1을 CPU로 연산 수행 -> 반복

### 멀티 코어 스케줄링
CPU코어가 여러개라면 한번에 더 많은 스레드를 물리적으로 실행 가능
여러 코어가 각 스레드를 병렬로 처리하며, 스케줄링 큐에서 코어당 작업을 분배
![[!Resources/Excalidraw/MultiThread.md#^group=zCkXbIxhfwPMj3wycdXyH|900]]
# 컨텍스트 스위칭 (Context Switching)
컨텍스트 스위칭은 현재 실행 중인 스레드의 상태를 저장하고, 다른 스레드를 실행하기 위해 그 상태를 불러오는 과정이다. 
여기서 상태란, 현재 변수 값, 실행 중인 코드 위치 등이다. 이 과정에서 약간의 비용이 발생하는데, 이 비용은 **컨텍스트 스위칭 오버헤드**라고 한다.

컨텍스트 스위칭은 멀티스레드 환경에서 효율적일 수 있지만, 빈번하게 발생하면 시스템 성능에 영향을 미칠 수 있다. 
즉, 많은 스레드를 실행하는 것만으로는 항상 효율적이지 않다. 
오히려 스레드 수와 시스템 자원의 균형을 맞추는 것이 중요하다.
###### CPU 4코어 - 스레드 2개
CPU가 놀고 있지만, 컨텍스트 스위칭 비용이 적다. 이 경우, 시스템이 비교적 효율적으로 동작할 수 있다.
###### CPU 4코어 - 스레드 100개
CPU를 거의 100% 활용할 수 있지만, 컨텍스트 스위칭 비용이 급증한다. 이 경우, 너무 많은 스레드로 인해 성능 저하가 발생할 수 있다.
###### CPU 4코어 - 스레드 4개
이상적인 상황. 각 코어가 하나의 스레드를 처리하면서, 컨텍스트 스위칭 비용을 최소화한다.

#### CPU-바운드 작업
CPU의 연산 능력을 많이 요구하는 작업. 
예를 들어 복잡한 계산, 데이터 분석, 게임 등. 
이 경우 CPU 코어 수에 맞춰 스레드 수를 설정하는 것이 중요하다.
#### I/O-바운드 작업
네트워크나 파일 시스템과 같은 입출력 작업이 많은 작업. 
이 경우, CPU는 대기 시간에 상대적으로 많이 놀기 때문에, 더 많은 스레드를 생성해 CPU를 더 많이 활용할 수 있다.

###### 백엔드 서버에서의 활용
백엔드 웹 서버에서 사용자 요청을 처리할 때, 하나의 요청을 처리하는 데 1개의 스레드가 필요하다. 
예를 들어, 하나의 스레드가 1%의 CPU를 사용한다고 가정할 때, 4개의 CPU 코어가 있다고 해서 스레드 수를 4개로 맞추면, 
CPU는 4%만 사용하고 나머지 96%는 놀게 된다. 

이 경우, 스레드 수를 늘려서 CPU 자원을 최대한 활용하는 것이 중요하지만, 컨텍스트 스위칭의 비용도 함께 고려해야 한다.
따라서, 성능을 최적화하려면 **테스트와 튜닝**을 통해 적절한 스레드 수를 찾는 것이 필요하다.