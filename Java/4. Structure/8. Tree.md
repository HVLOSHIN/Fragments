# Tree
- 부모 노드와 자식 노드로 구분, 최상위 조상은 `root`라 한다.
- 자식이 2개까지 있는 트리를 **이진 트리**라 한다.
- 왼쪽이 더 작은 값을 유지할 경우, **이진 탐색 트리**라 한다.

```java
class Node {
	Object item;
	Node left;
	Node right;	
}
```
왼쪽 자식, 오른쪽 자식을 연결하는 연결리스트?


### 이진 탐색 트리
핵심은 데이터를 입력하는 시점에 **정렬**해서 보관한다는 점이다.


###### 데이터 삽입 예시
10, 5, 15, 1, 6, 11, 16 순서대로 입력

![[!Resources/Excalidraw/Collection Framework.md#^group=MlXuIrNhfx6RIT6hZk-iz|600]]
- 10은 `root`
- 5는 10보다 작으므로 왼쪽
- 15는 10보다 크므로 오른쪽
- 1은 10보다 작으므로 왼쪽 -> 5보다 작으므로 왼쪽
- 6은 10보다 작으므로 왼쪽 -> 5보다 크므로 오른쪽
느낌 오시쥬?

###### 데이터 검색 예시
16을 검색
- 루트인 10 보다 크므로 오른쪽
- 그 다음 루트인 15보다 크므로 오른쪽

데이터는 총 7개인데, 2번의 계산으로 결과를 얻었다.
`O(n)` 보다는 빠르고, `O(1)`보다는 느리다.  -> `O(log n)`
이진 탐색 트리는 한번의 탐색으로 절반을 날릴 수 있다. ~~타노스트리~~


> [!note] 오랜만에 수학 복습
> 16개의 데이터 -> log2(밑) 16(진수) = 4(지수) 
> 1024개의 데이터 -> 연산 10회
> 데이터의 크기가 늘어날 수록 효율이 좋아진다.


###### 최악의 경우
![[!Resources/Excalidraw/Collection Framework.md#^group=r_0u37heYlnovIW9Bsij0|400]]
이런식으로 입력되는 숫자가 치우치는 경우 (일관적으로 커지거나 작아지는 경우) ->  `O(n)`

### 이진 탐색 트리 개선
트리의 균형이 너무 깨진 경우, 동적으로 리밸런싱
위 최악의 경우를 예시로 들면, 5나 6을 루트로 설정하여 재정렬하는 작업을 함

Java에서는 `레드 블랙 트리`라는 알고리즘을 사용하여 균형을 유지한다.
따라서 최악의 경우에도 `O(log n)`의 성능을 제공한다.


###### 이진 탐색트리의 순회
![[!Resources/Excalidraw/Collection Framework.md#^group=MlXuIrNhfx6RIT6hZk-iz|600]]



(루트기준) 왼쪽 서브 트리 순회 - 루트 - 오른쪽 서브 트리 순회
서브트리 내부에서도 마찬가지 방법으로 순회 수행
해당 예시를 순회해보면
1 - 5 - 6 -10 - 11 - 15 - 16 



