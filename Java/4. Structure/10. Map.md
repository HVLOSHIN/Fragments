---
tags:
  - fragment
  - java
---
# Map
###### Map의 특징
- `Key` - `Value`가 한 쌍
- `Key` : 유일성 보장, key를 통해 값을 빠르게 검색 가능
- `Value` : 중복 허용
- 순서를 유지하지 않음 (구현체에 따라 다름)
###### Map 주요 메서드
```java
Map<String, Integer> map = new HashMap<>();  
map.put("A", 90);  
map.put("B", 80);  
map.put("C", 80);  
System.out.println(map);
```

```
{A=90, B=80, C=80}
```


```java
// 조회  
System.out.println(map.get("A"));  
  
// key를 Set으로 추출  
Set<String> keys = map.keySet();  
System.out.println(keys);  
  
// Value 추출  
Collection<Integer> values = map.values();  
System.out.println(values);  
  
// entry(key + value) 추출  
Set<Map.Entry<String, Integer>> entries = map.entrySet();  
for (Map.Entry<String, Integer> entry : entries) {  
    System.out.println(entry.getKey() + " : " + entry.getValue());  
}
```

```
90
[A, B, C]
[90, 80, 80]
A : 90
B : 80
C : 80
```

> [!note] Entry
> 키-값 쌍(**key-value pair**)을 나타내는 개념
> Java에서는 `Map.Entry` 인터페이스를 사용하여 `Map`의 각 항목(키-값 쌍)을 다룰 수 있다.
> 이를 통해 효율적으로 `Map`의 데이터를 순회하거나 수정할 수 있다.

> [!note] Value 추출
> Value는 중복을 허용하고, 순서를 보장하지 않는다. 
> 따라서 순서를 보장하는 List나 중복을 허용하지 않는 Set으로 반환하기 보다는 
> 값의 모음이라는 의미로 상위 인터페이스인 `Collection`으로 반환한다.

```java title:"Key는 중복허용X"
HashMap<String, Integer> map = new HashMap<>();  
map.put("A", 90);  
map.put("A", 80);  
System.out.println(map.get("A"));
```

```
80
```
동일한 key 에 새로운 값을 넣으면 덮어써버린다.


```java
HashMap<String, Integer> map = new HashMap<>();  
map.put("A", 90);  
map.remove("A");  
System.out.println(map);
```

```
{}
```
`remove()` 사용시, key - value 둘 다 제거됨


```java
HashMap<String, Integer> map = new HashMap<>();  
map.put("A", 90);  
map.putIfAbsent("A", 70);  
map.put("B", 80);  
System.out.println(map);
```

```
{A=90, B=80}
```
`putIfAbsent()` : key가 존재하지 않거나 value가 `null`일 때만 데이터 추가
# Map 구현

key는 [[9. Set#1. HashSet|Set]]을 기반으로 함 (유일성 , 순서 미보장)
value는 단순히 key옆에 따라붙은 것이라고 봐도 무방하다.
**Map의 본질은 Set**
이러한 이유로 Map의 구현체는 Set과 거의 동일하다.
- HashSet -> HashMap
- LinkedHashSet -> LinkedHashMap
- TreeSet -> TreeMap

> [!note] 
> 더 정확히는 Set의 본질이 Map 이다.
> 실제로 Java `HashSet`의 구현은 대부분 `HashMap`의 구현을 가져다 사용한다.
> Map에서 value대신 Dummy Object를 사용하면(사실상 비워두는 거) Set으로 사용가능 하다.
> 
### 1. HashMap
- [[7. Hash|Hash]]를 사용하여 key 저장
- key를 통해 조회하므로 검색, 삽입, 삭제 `O(1)`
- 순서 미보장

### 2. LinkedHashMap
- [[5. List#LinkedList|연결리스트]]를 사용하여 **데이터 입력 순서 보장**
- 검색, 삽입, 삭제 `O(1)` ([[9. Set#^8ebe43|HashMap 보다는 조금 느림]])

### 3. TreeMap
- [[8. Tree#이진 탐색 트리 개선|레드-블랙 트리]]를 기반으로 구현
- 모든 키는 `Comparator`에 의해 **정렬순서 보장**
- 검색, 삽입, 삭제 `O(log n)`



```java
public static void main(String[] args) {  
    run(new HashMap<>());  
    run(new LinkedHashMap<>());  
    run(new TreeMap<>());  
}  
  
private static void run(Map<String, Integer> map) {  
    System.out.println(map.getClass());  
    map.put("C", 10);  
    map.put("B", 20);  
    map.put("A", 30);  
    map.put("1", 40);  
    map.put("2", 50);  
    
	// 출력, 반복문 생략
}
```

```
class java.util.HashMap        // 입력 순서 미보장 O(1)
A:30  1:40  B:20  2:50  C:10  

class java.util.LinkedHashMap  // 입력순서 보장 O(1)
C:10  B:20  A:30  1:40  2:50  

class java.util.TreeMap         // 키의 값을 기준으로 정렬 보장 O(log n)
1:40  2:50  A:30  B:20  C:10  
```
key의 값 (HashCode)에 의해 정렬이 되는지 유무를 확인할 수 있다.

![[!Resources/Excalidraw/Collection Framework.md#^group=gVj401sMKP37nzbTJ0Ela|900]]


> [!note] 해시 테이블
> 해시를 사용해서 key - value를 저장하는 자료구조
> HashSet은 해시테이블의 원리를 사용하지만, Key만 저장하는 특수한 해시 테이블이라 이해하면 될 듯 하다.

> [!caution] 
> Map에서 Key로 사용되는 객체는 `hashCode()`, `equals()`를 [[6. Set DIY#equals, hashCode의 중요성|반드시 구현]]해야 한다.



