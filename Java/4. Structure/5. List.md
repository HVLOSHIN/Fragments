---
tags:
  - fragment
  - java
  - ★★★★
---
# ArrayList
[[8. Array|배열]]의 [[2. Collection Framework Intro#배열의 한계|고질적인 단점]]을 개선하기 위해 List 도입
[[3. ArrayList DIY|ArrayList DIY 구현]]
###### ArrayList의 특징
- **순서 보장** : 요소가 추가된 순서를 유지
- **중복 허용** : 동일한 요소의 중복 저장이 가능
- **동적 크기 조절** : 요소가 추가될 때 자동으로 배열의 크기가 증가
- **빠른 데이터 접근** : 인덱스를 사용해 특정 요소에 빠르게 접근 `O(1)`
###### ArrayList의 단점
- **메모리 낭비:** 배열의 뒷부분에 사용되지 않는 공간 존재 가능
- **데이터 추가/삭제 비효율성:** 중간에 데이터를 추가하거나 삭제할 경우 `O(n)`
- **성능 한계:** 대용량 데이터 처리 시 배열 복사가 빈번할 경우 성능 저하
###### ArrayList를 사용하면 좋은 경우
- 요소의 **순차적 추가/삭제**가 많을 때
- 요소를 **자주 조회**할 때
- 데이터의 **중복 저장**이 필요할 때
###### ArrayList를 피해야 하는 경우
- **중간 삽입/삭제**가 빈번할 때
- **메모리 최적화**가 중요한 경우

# LinkedList
[[4. LinkedList DIY|LinkedList DIY 구현]]
![[!Resources/Excalidraw/Collection Framework.md#^group=S8cjQVXhZBfNWCEwcFkGk|1000]]
- **노드(Node):** 각 노드는 데이터(item)와 다음 노드에 대한 참조`next`를 가짐.
- 각각의 노드가 참조를 통해 연결(Link) 되어있다.
- **참조값 관리:** 배열과 다르게 데이터 추가/삭제 시 밀고 당기는 작업이 필요 없음.
###### LinkedList의 특징
- 순서 보장 : 요소가 추가된 순서를 유지
- 중복 허용 : 동일한 요소의 중복 저장 가능
- **동적 메모리 할당:** 필요한 만큼만 노드를 생성하여 메모리 낭비 최소화
- **빠른 데이터 추가/삭제:** 중간에 요소를 추가하거나 삭제할 때 효율적 `O(1)`
- **느린 데이터 접근:** 특정 인덱스를 조회할 때 순차 탐색이 필요 `O(n)`
###### LinkedList의 단점
- **느린 데이터 접근:** 인덱스를 통해 특정 요소에 접근할 때 비효율적 `O(n)`
- **메모리 오버헤드:** 각 노드가 데이터와 참조를 저장해야 하므로 추가 메모리 필요
- **캐시 비효율성:** 노드들이 메모리에 연속적으로 저장되지 않아서 캐시 효율이 낮음
###### LinkedList를 사용하면 좋은 경우
- **중간 삽입/삭제**가 빈번할 때
- 데이터 추가/삭제가 많고 조회가 적을 때
- 메모리 최적화가 덜 중요할 때
###### LinkedList를 피해야 하는 경우
- 요소를 **자주 조회**해야 할 때
- 대용량 데이터를 순차적으로 저장해야 할 때


> [!note] 배열리스트와 연결리스트를 같은 "**리스트**"로 분류하는 이유
> 두 자료구조가 공통적으로 **데이터를 순차적으로 저장하고 관리하는 선형 자료구조**이기 때문이다.

# [[2. Collection Framework Intro#빅오(O) 표기법|성능]] 비교

###### 추가(Addition)

| 작업     | ArrayList | LinkedList | Big-O                                  |
| ------ | --------- | ---------- | -------------------------------------- |
| 앞에 추가  | 1338ms    | **2ms**    | `ArrayList`: O(n) / `LinkedList`: O(1) |
| 중간에 추가 | 700ms     | 1066ms     | `ArrayList`: O(n) / `LinkedList`: O(n) |
| 뒤에 추가  | **2ms**   | 2123ms     | `ArrayList`: O(1) / `LinkedList`: O(n) |

- LinkedList는 앞에 추가할 때 빠르다. (O(1))
- ArrayList는 뒤에 추가할 때 압도적으로 빠르다. (O(1))
- 중간에 추가는 두 리스트 모두 O(n)이지만, ArrayList가 더 효율적이다.

###### 조회(Get)

| 작업              | ArrayList | LinkedList | Big-O                                  |
| --------------- | --------- | ---------- | -------------------------------------- |
| 0번째 조회          | 1ms       | 0ms        | `ArrayList`: O(1) / `LinkedList`: O(1) |
| 중간 조회 (25000번째) | **1ms**   | 424ms      | `ArrayList`: O(1) / `LinkedList`: O(n) |
| 끝 조회 (49999번째)  | **0ms**   | 846ms      | `ArrayList`: O(1) / `LinkedList`: O(n) |

- ArrayList는 조회가 항상 빠르다. (O(1))
- LinkedList는 인덱스를 통해 접근할 때 성능이 저하된다. (O(n))
###### 검색(Search)

| 작업                | ArrayList | LinkedList | Big-O                                  |
| ----------------- | --------- | ---------- | -------------------------------------- |
| 0번째 값 검색          | 0ms       | 0ms        | `ArrayList`: O(n) / `LinkedList`: O(n) |
| 중간 값 검색 (25000번째) | **117ms** | 480ms      | `ArrayList`: O(n) / `LinkedList`: O(n) |
| 끝 값 검색 (49999번째)  | **225ms** | 939ms      | `ArrayList`: O(n) / `LinkedList`: O(n) |

- 두 리스트 모두 검색은 O(n)이다.
- ArrayList가 검색 속도가 더 빠르다.


> [!note] LinkedList가 실 성능이 구린이유
> ArrayList는 배열의 요소들이 메모리상에서 **연속적으로 위치**하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.
> 반면 LinkedList는 각 요소가 **별도의 객체로 존재**하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어진다.
> 물론 ArrayList는 Capacity 라는 요소 까지 고려해야 하지만, 자주 발생하는 일이 아니므로 전체성능에는 큰 영향이 없다.
>결론 : 이론상과 실제 성능차이는 큰 차이가 있을 수 있다.


# 결론

| 비교 항목       | ArrayList       | LinkedList       |
| ----------- | --------------- | ---------------- |
| 데이터 접근      | **빠름** (`O(1)`) | 느림 (`O(n)`)      |
| 데이터 추가 (뒤)  | **빠름** (`O(1)`) | 느림 (`O(n)`)      |
| 데이터 추가 (중간) | 느림 (`O(n)`)     | **빠름** (`O(1)`)  |
| 메모리 사용      | 비효율적 (빈 공간 발생)  | 효율적 (필요한 만큼만 사용) |
| 순차 접근       | 효율적             | 비효율적             |

일반적인 경우, ArrayList가 더 나은 선택지
삽입/삭제가 빈번할 경우:** **LinkedList** 사용