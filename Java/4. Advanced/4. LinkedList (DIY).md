---
tags:
  - java
  - fragment
---
##### [[3. ArrayList (DIY)#MyArrayList의 단점|ArrayList]]의 단점
- 사용되지 않은 공간 낭비 : 배열은 공간을 미리 확보해 놔야 한다. 따라서 확보해 놓은 공간은 채워지기 전까지는 낭비된다.
- 배열의 중간에 데이터 추가 : 앞이나 중간에 데이터를 추가하면 기존 데이터들을 오른쪽으로 이동시켜야 한다.
  삭제의 경우에는 빈 공간을 채우기 위해 왼쪽으로 이동해야 한다. 이 과정이 상당히 비효율적이다.

# 노드와 연결 (Link)
낭비되는 메모리 없이 딱 필요한 만큼만 메모리 확보?
앞이나 중간의 데이터를 추가/ 삭제할 때도 효율적인 방법이 없는가?

![[!Resources/Excalidraw/Collection Framework.md#^group=S8cjQVXhZBfNWCEwcFkGk|1000]]

```java
public class Node {
	Object item;
	Node next;
}
```
노드 클래스는 내부에 저장할 데이터인 `item`과, 다음으로 연결할 노드의 참조인 `next`를 가진다.


```java
public static void main(String[] args) {  
    // 노드 생성하고 연결하기 A - B - C    Node first = new Node("A");  
    first.next = new Node("B");  
    first.next.next = new Node("C");  
  
    System.out.println("모든 노트 탐색하기");  
    System.out.println("first.item = " + first.item);  
    System.out.println("first.next.item = " + first.next.item);  
    System.out.println("first.next.next.item = " + first.next.next.item);  
}
```

```
모든 노트 탐색하기
first.item = A
first.next.item = B
first.next.next.item = C
```
어렵지 않쥬?

```java
public static void main(String[] args) {  
    // 노드 생성하고 연결하기 A - B - C    Node first = new Node("A");  
    first.next = new Node("B");  
    first.next.next = new Node("C");  
  
    System.out.println("모든 노트 탐색하기");  
    Node x = first;  
    while (x != null) {  
        System.out.println(x.item);  
        x = x.next;  
    }
}
```

```
모든 노트 탐색하기
A
B
C
```
이런식의 탐색도 가능하다.

 