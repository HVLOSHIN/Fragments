---
tags:
  - fragment
  - java
---
# List
[[8. Array|배열]]의 고질적인 단점인 [[2. Collection Framework Intro#배열의 한계|정적인 크기를 가지는 점]]을 개선하기 위해 List 도입
- 순서가 있다
- 중복을 허용한다.
- 크기가 동적으로 변할 수 있다.
### List 직접 구현해 보기1
```java
public class MyArrayListV1 {  
    public static final int DEFAULT_CAPACITY = 5;  
  
    private Object[] elementData;  
    private int size = 0;  

	// Default 배열 크기
    public MyArrayListV1() {  
        elementData = new Object[DEFAULT_CAPACITY];  
    }  
    // 배열 크기 커스텀 가능
    public MyArrayListV1(int initialCapacity) {  
        elementData = new Object[initialCapacity];  
    }
    public int size(){  
        return size;  
    }  
    // add
    public void add(Object e){  
        elementData[size] = e;  
        size++;  
    }  
    // 조회
    public Object get(int index){  
        return elementData[index];  
    }  
    // 수정
    public Object set(int index, Object element){  
        Object oldValue = get(index);  
        elementData[index] = element;  
        return oldValue;  
    }
    // index 조회    
    public int indexOf(Object o){  
        for (int i = 0; i < size; i++) {  
            if(o.equals(elementData[i])){  
                return i;  
            }        
        }        
    return -1;  
    }  
    public String toString(){  
        return Arrays.toString(Arrays.copyOf(elementData, size)) +  
                ", size = " + size + ", capacity = " + elementData.length;  
    }
}
```

> [!note] Size vs Capacity
> 둘 다 크기를 나타내지만 의미하는 바가 다르다.
> - size : 리스트의 크기 (실제로 입력된 데이터가 있는 크기)
> - capacity : 배열의 크기
> `[1, 2, 3, null, null]` / size = 3 / capacity = 5

### List 직접 구현해 보기2 - 동적 배열
```java
 public void add(Object e){  
        // 코드 추가  
        if(size == elementData.length){  
            grow();  
        }        elementData[size] = e;  
        size++;  
    }  
    private void grow() {
        elementData = Arrays.copyOf(elementData, elementData.length * 2);  
    }
```
`Arrays.copyOf(기존배열, 새로운 길이)` : 새로운 길이로 배열을 생성하고, 기존 배열의 값을 새로운 배열에 복사한다.
또한 새롭게 생성된 List로 참조값을 갈아탄다. 기존 배열은 더 이상 참조하는 곳이 없으므로 [[2. Referance#^23bd4f|GC]]의 대상이 된다. 

```java
public class MyArrayListV2Main {  
    public static void main(String[] args) {  
        MyArrayListV2 list = new MyArrayListV2();  
        list.add("a");  
        list.add("b");  
        list.add("c");  
        list.add("d");  
        list.add("e"); 
        System.out.println(list); 
        list.add("f");  
        System.out.println(list);  
    }
}
```

```
[a, b, c, d, e], size = 5, capacity = 5
[a, b, c, d, e, f], size = 6, capacity = 10
```
capacity가 2배로 늘어나면서 최대 수용량을 늘렸다.
~~다시 줄이는건 고려를 하지않은건가?~~

> [!note] 배열의 크기를 1씩 증가시키면?
> 배열을 복사하는 연산이 너무 자주 발생한다.
> 항상 데이터가 1억개쯤 있다고 가정하고 생각해보자
> 복사하는 연산이 자주 일어나지 않게 하는것도 좋은 최적화 방법이다.
> 반대로 배열의 크기를 너무 크게 증가시키면 낭비되는 메모리가 많아지는 단점 또한 존재한다.

### List 직접 구현해 보기 - 기능 개선
`add(index, data)` 인덱스를 활용하여 특정 위치에 데이터를 추가시켜보는 기능을 추가해 보자


