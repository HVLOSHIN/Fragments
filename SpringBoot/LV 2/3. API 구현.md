---
tags:
  - fragment
  - spring
text: "[[Spring]]"
---
# BluePrint
블로그를 만들것이다.
- 프레젠테이션 계층 : controller
- 비즈니스 계층 : service
- 퍼시스턴스 계층 : repository
- 데이터베이스와 연결되는 DAO : domain


# 1. Domain (Entity)
- id - int - PK - AutoIncrement
- title - varchar - notnull - 제목
- content - varchar - notnull - 내용

~~~java
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Getter  
@Entity // 엔티티로 지정  
public class Article {  
    @Id  // 기본키(PK)로 지정
    @GeneratedValue(strategy = GenerationType.IDENTITY) //AutoIncrement  
    @Column(name = "id", updatable = false)  
    private Long id;  
  
    @Column(name = "title", nullable = false)  
    private String title;  
  
    @Column(name = "content",nullable = false)  
    private String content;  
  
    @Builder // 빌더 패턴으로 객체 생성  
    public Article(String title, String content) {  
        this.title = title;  
        this.content = content;  
    }  
}
~~~

> [!note] @Builder
> @Builder는 롬복에서 지원하는 어노테이션이다.
> 빌더패턴을 사용하면 필드에 어떤값이 들어가는지 명시적으로 파악할 수 있다.
> 
~~~java
// 빌더 패턴 X
new Article("abc","def");  
  
// 빌더 패턴 O
Article.builder()  
    .title("abc")  
    .content("def")  
    .build();
~~~
어느 필드에 들어가는지 명확해 졌다. (가독성 향상)

# 2. Repository
~~~java
public interface BlogRepository extends JpaRepository<Article, Long> {  }
~~~
JpaRepository 클래스를 상속받을 때 엔티티 Article과 엔티티의 PK 타입인 Long을 인수로 넣어줬다.

덕분에 JpaRepository에서 제공하는 여러 메서드를 사용할 수 있게됐다.


# 3. DTO
~~~java
@NoArgsConstructor  
@AllArgsConstructor  
@Getter  
public class AddArticleRequest {  
    private String title;  
    private String content;  
  
    public Article toEntity(){  // 생성자를 사용해 객체 생성  
        return Article.builder()  
                .title(title)  
                .content(content)  
                .build();  
    }  
}
~~~
`toEntity()` 는 빌더패턴을 사용하여 DTO를 엔티티로 만들어주는 메서드

# 4. Service
~~~java
@RequiredArgsConstructor //final, @NotNull 이 붙은 필드의 생성자 추가  
@Service // 빈으로 등록  
public class BlogService {  
    private final BlogRepository blogRepository;  
  
    //블로그 글 추가 메서드  
    public Article save(AddArticleRequest request) {  
        return blogRepository.save(request.toEntity());  
    }  
}
~~~

- `save()` 메서드는 JpaRepository에서 지원하는 저장 메서드
- AddArticleRequest (DTO) 에 저장된 값들을 article 데이터베이스에 저장한다. 

# 5. Controller
~~~java
@RequiredArgsConstructor  
@RestController  
public class BlogApiController {  
    private final BlogService blogService;  
      
    @PostMapping("/api/articles")  
    // @RequestBody로 요청 본문 값 매핑  
    public ResponseEntity<Article> addArticle(@RequestBody AddArticleRequest request) {  
        Article saveArticle = blogService.save(request);  
          
        return ResponseEntity.status(HttpStatus.CREATED).body(saveArticle);  
    }  
}
~~~

- `@RestController` : HTTP 응답으로 객체 데이터를 JSON 형식으로 반환한다.
-  `ResponseEntity.status().body()` : 응답코드 / 객체를 반환한다. 

  ![[복습 2차.png]]