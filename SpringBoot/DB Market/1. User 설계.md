---
tags:
  - fragment
  - spring
  - "#project"
text: "[[Spring]]"
---

프로젝트를 잘 마친거 같지만, 이 정보들이 온전히 나의 것이라고는 생각하지 않는다.
꼭꼭 씹어먹으면서 나의 것으로 소화해 나가는 과정이 필요하다.

# 1. Entity - DTO

~~~java title:"Entity"
@AllArgsConstructor  
@NoArgsConstructor  
  
@Setter  
@ToString  
@Getter  
@Entity  
@Table  
public class User {  
    @Id   
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long userId;  
  
    @Column(nullable = false)  
    private String userName;  
  
    @Column(nullable = false)  
    private String password;
}    
~~~

~~~java title:"DTO"
@Getter  
@AllArgsConstructor  
public class UserDto {  
    private String username;  
    private String password;
~~~

[[1. SpringBoot 주요 개념#DAO, DTO, VO|DTO]] : 계층간 데이터 교환을 위한 객체
[[8. DataBase Modeling#Entity|Entity]] : 데이터 베이스에 저장되는 객체 

### DTO와 Entity 분리의 장점
사실 이번 프로젝트에 아쉬운 부분은 UserDTO 보다는 User 엔티티를 그냥 불러와서 썼다는 점이다.

엔티티를 가져와서 쓸때 편한점  (대부분 귀찮은 부분들인듯)
- ID 값을 사용할 수 있다.
- 선언할 때 `User user` 가 `UserDto user` 보다 더 직관적인건 사실이다.
- DTO를 쓴다면 레파지토리에서 User를 가져온다음 한번 변환작업을 거쳐야 하는 불편함이 있다.

DTO를 도입해야 할 시점
- 시스템 **규모가 커지고 복잡**해질 때: 엔티티와 뷰 사이의 데이터를 효과적으로 관리하기 위해
- 다양한 클라이언트에서 데이터를 사용할 때: 각 클라이언트에 맞는 데이터 형식으로 변환하기 위해 DTO를 사용하면 편리
  엔티티를 사용하면 모든 데이터가 반환되기 때문에, DTO를 통해서 필요한 부분만 전송할 수 있다.
- 데이터 **보안**이 중요할 때: 민감한 정보를 노출시키지 않기 위해

DTO 분리의 장점
- 엔티티의 구조가 변해도 클라이언트에 직접적으로 영향을 미치지 않는다. (영향 최소화)
- 엔티티 보호가능 (DTO에서만 Setter 사용시)
- 보낼 데이터를 선별가능 : 엔티티에서 필요한 데이터만 DTO로 보내면 보안, 최적화 둘다 잡을 수 있다


# 2. 의존관계 주입

~~~java
@RequiredArgsConstructor  
@Controller  
public class UserController {  
    private final UserService userService;  
    private final UserFilter userFilter;
	.
	.
	.
~~~

`{java}@RequiredArgsConstructor` : final이 붙은 필수 필드들을 자동으로 [[6. 의존관계 자동주입#final 키워드|생성자]]를 만들어주면서 의존주입도 동시에 일어난다.
-> `{java}@Autowired` 가 필요없다!

지금은 UserService, UserFilter 클래스를 자동으로 의존관계 주입해줬다.
개인적으로 이방식이 가장 간결한것 같다.

# 3. Repository

~~~java title:"Repository"
public interface UserRepository extends JpaRepository<User, Long> {  
    // 로그인 로직  
    User findByUserNameAndPassword(String username, String password);  
    User findByUserName(String userName);  
    User findByUserId(Long userId);  
}
~~~
저장소 역할



# 3. 로그인
~~~java title:"컨트롤러"
@PostMapping("/users/login")  
public String login(@RequestParam("username") String username, 
					@RequestParam("password") String password, 
					HttpServletRequest httpServletRequest,Model model) {  
    userService.isSessionAvailable(model);  
    return userService.login(username, password, httpServletRequest);  
}
~~~

~~~java title:"서비스"
// 로그인 로직  
public String login(String username, String password, HttpServletRequest httpServletRequest) {  
    // 입력한 username-password 를 모두 충족하지 못하면 null    
    User user = userRepository.findByUserNameAndPassword(username, password);  
  
    // 로그인 검증 로직  
    if (user == null) {  
        log.info("로그인 실패 : 존재하지 않는 계정");  
        return "redirect:/users/login?error= not_exist";  
    }    String password1 = Encrypt.md5(password);  
    String password2 = Encrypt.md5(user.getPassword());  
  
    if (!password1.equals(password2)) {  
        log.info("로그인 실패 : 틀린 비밀번호");  
        return "redirect:/users/login?error=wrong_password";  
    }    log.info("로그인 성공, 세션 부여");  
    HttpSession httpSession = httpServletRequest.getSession(true);  
    httpSession.setAttribute("user", user);  
  
    return "redirect:/categories";  
}
~~~

[[3. MVC Pattern|MVC 패턴]] 을 한번에 보여주는 케이스

`{java}@RequestParam("파라미터 이름")` 을 통해 뷰페이지에서 입력한 내용을 매개변수로 가져와 담을 수 있다.

컨트롤러는 매개변수를 서비스로 보내는 단순한 역할만 한다.
[[10. Service, Transaction|서비스]]는 비즈니스 로직을 수행한다.

- 레파지토리에서 아이디와 비밀번호를 가져온다.
- 검증로직을 통해 로그인 성공 여부 결정
- 로그인 성공하면 세션 부여
- URL 반환